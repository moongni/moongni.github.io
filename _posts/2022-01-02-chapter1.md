---
layout: single
title: "Small Problems-modified"
categories: algorithm
tags: [python, algorithm, fibonacci sequence, recursion, generator]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 알고리즘 학습동아리 1주차

## 교재소개
![http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791162242469](http://image.kyobobook.co.kr/images/book/large/469/l9791162242469.jpg)
고전 컴퓨터 알고리즘 인 파이썬: 피보나치 수열부터 보드게임까지, 알고리즘으로 풀어보는 고전 문제 43선  

## 1. Small problems

문제해결 방식에 대해 흥미로운 시각을 제시할 수 있는 작은 문제들을 살펴본다.  

### 1.1 피보나치 수열
피보나찌 수열은 첫째항을 0, 두번째 항을 1로 두고 그 다음의 항들은 직전 두 항의 합인 수열이다.  
`0, 1, 1, 2, 3, 5, 8, 13, 21...`  

<pre>
0번째 항이 0부터 시작할 경우의 점화식은
fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2) (n| {2,3,4,...}))
</pre>


#### 1.1.1 재귀함수
1.1의 피보나치 수열을 재귀(recursion)방식을 통해 python function으로 구현한다.


```python
#fib1
def fib1(n: int):
    return fib1(n-1) + fib1(n-2)
```

fib1()에 값을 넣어 결과를 보면
```python
print(fib1(5))
```
`RecursionError: maximum recursion depth exceeded`  
재귀에러가 뜨며 fib1()이 결과를 return하지 않고 무한 재귀(infinite recursion)상태에 빠진다.

#### 1.1.2 재귀함수와 기저조건
fib1()을 실행할 때까지 파이썬 인터프리터는 무한 재귀를 호출한다고 알려주지 않는다.  

`기저조건(base case)`: 재귀 함수에서 재귀함수를 탈출하는 조건이다.  


```python
#fib2
def fib2(n: int):
    if n < 2: #기저 조건
        return n
    return fib2(n-2) + fib2(n-1) #재귀 조건
```


```python
print(fib2(5))
print(fib2(10))
```

    5
    55
    

다만 fib2()함수에 50정도의 수만 넣어도 실행시간이 굉장히 길어질 것이다.  
fib2()를 호출할 때마다 fib2(n-1)과 fib2(n-2)를 통해 호출트리가 기하급수적으로 커진다.    
![](https://mblogthumb-phinf.pstatic.net/MjAxNzA2MjVfODIg/MDAxNDk4MzcwMDY4MDI0.2iMM7voZ2nUGQ4dhTwuY7Hx7-s3aSROUGPXvN0sUN68g.EWhVpEGqpEgTIzzgGdlk86_vJ2kZqyQ1RBtd7izdSAUg.PNG.archslave/2.png?type=w800)  
기저 조건에 해당하지 않는 모든 fib2() 호출은 fib2()를 2번 이상 호출한다.


```python
import time

for n in range(30, 35, 1):
    start = time.time() #시작 시간 측정
    print(fib2(n))
    print(f"fib2({n}) time :", time.time() - start)    
```

    832040
    fib2(30) time : 0.25970911979675293
    1346269
    fib2(31) time : 0.4317185878753662
    2178309
    fib2(32) time : 0.6557610034942627
    3524578
    fib2(33) time : 1.1117711067199707
    5702887
    fib2(34) time : 1.7992608547210693
    

fib2()의 수열의 요소 숫자가 증가할 수록 함수 호출 증가 횟수는 더 악화된다.  
`fib2(5) => 15회 호출`  
`fib2(10) => 177회 호출`  
`fib2(20) => 21891회 호출`

#### 1.1.3 메모이제이션
메모이제이션은 계산 작업이 완료되면 결과를 저장하는 기술이다.   
이전에 실행된 같은 계산을 수행할 때 다시 계산하지 않고 저장된 값을 사용한다.


```python
#fib3
from typing import Dict

memo: Dict[int, int] = {0: 0, 1: 1} #기저 조건

def fib3(n: int):
    if n not in memo:
        memo[n] = fib3(n-1) + fib3(n-2)
    return memo[n]
```


```python
import time

start = time.time() #fib2의 시작 시간 측정
print(fib2(20))
print("fib2(20) time :", time.time() - start) 

start = time.time() #fib3의 시작시간 측정
print(fib3(20))
print("fib3(20) time :", time.time() - start)
```

    6765
    fib2(20) time : 0.0019981861114501953
    6765
    fib3(20) time : 0.0
    

fib2(20)은 자신을 21,891번 호출하는 반면 fib3(20)은 39번을 호출한다.  

#### 1.1.4 메모이제이션 데커레이터
fib3()를 더 단순화할 수 있다. 파이썬에 모든 함수를 자동으로 메모이징하는 내장형 데커레이터`@functools.lru_cache()`를 사용하여 fib4()를 작성한다. 
  
  
fib2()와 같은 코드를 사용하지만 fib4()가 실행될 때 마 데커레이터는 계산된 반환값을 메모리에 캐싱(저장)한다. 이후 동일한 인자와 fib4()가 실행되면 캐시된 값을 검색하여 반환한다.  


```python
#fib4
from functools import lru_cache

@lru_cache(maxsize = None)
def fib4(n: int):
    if n < 2:
        return n
    return fib4(n-2) + fib4(n-1)
```


```python
import time

start = time.time() #fib2의 시작 시간 측정
print(fib2(20))
print("fib2(20) time :", time.time() - start) 

start = time.time() #fib4의 시작시간 측정
print(fib4(20))
print("fib4(20) time :", time.time() - start)
```

    6765
    fib2(20) time : 0.0020313262939453125
    6765
    fib4(20) time : 0.0
    

`@lru_cache`의 `maxsize`속성은 데커레이터 함수에서 가장 최근의 호출을 캐시할 수 있는 크기이다. None은 캐시에 제한이 없다는 것을 의미한다.

#### 1.1.5 간단한 피보나치수열
고전적인 방식으로 피보나치 수열을 풀어보면


```python
#fib5
def fib5(n: int):
    if n == 0: return n
    last: int = 0 #fib(0)
    next: int = 1 #fib(1)
    for _ in range(1, n):
        last, next = next, last + next
    return next
```


```python
import time

start = time.time() #fib2의 시작 시간 측정
print(fib2(20))
print("fib2(20) time :", time.time() - start) 

start = time.time() #fib5의 시작시간 측정
print(fib5(20))
print("fib5(20) time :", time.time() - start)
```

    6765
    fib2(20) time : 0.0019998550415039062
    6765
    fib5(20) time : 0.0
    

note: fib5()의 for문은 [튜플 언패킹(tuple unpacking)](https://www.pythontutorial.net/python-basics/python-unpacking-tuple/) 을 사용했다.  
변수 `last`는 변수 `next`의 이전값으로 갱신되고  
변수 `next`는 `last`의 이전 값 + `next`의 이전값 으로 설정된다.  
**즉 변수 `last`가 갱신된 후 변수 `next`가 전에 변수 `next`의 이전 값을 저장할 임시 변수를 만들지 않아 메모리를 절약할 수 있다.**  
변수를 `swap`할 때 튜플 언패킹을 사용하는 것은 파이썬에서 일반적이다.

fib5()는 피보나찌 수열을 구하는 가장 효율적인 방법으로 for 문이 최대 n-1회 실행된다.  
fib5(20)은 19회 순회한다.  
단순 재귀의 경우 `상향식(bottom-up)`방식으로 계산한다. fib5()의 경우 `하향식(top-down)`방식으로 계산한다.  
fib1(), fib2()처럼 때론 재귀가 문제를 해결하는 가장 직관적인 방법이지만 성능에 문제가 일어날 수 있다.

#### 1.1.6 제너레이터와 피보나치 수
피보나찌 수열의 해당 단일값까지 전체 수열을 구하려면 `yield` 문을 사용하여 fib5()를 파이썬 제너레이터로 쉽게 변환할 수 있다.
[Generator 참고문헌](https://nvie.com/posts/iterators-vs-generators/)


```python
#fib6
from typing import Generator

def fib6(n: int) -> Generator[int, None, None]:
    yield 0 #특수 조건 fib(0)
    if n > 0: yield 1 #특수 조건 fib(1)
    last: int = 0  #fib(0)
    next: int = 1  #fib(1)
    for _ in range(1, n):
        last, next = next, last+next
        yield next #제너레이터 핵심 반환문
```


```python
count = 0
for i in fib6(50):
    print(f"fib6({count}) = {i}\t", end='')
    count += 1
```

    fib6(0) = 0	fib6(1) = 1	fib6(2) = 1	fib6(3) = 2	fib6(4) = 3	fib6(5) = 5	fib6(6) = 8	fib6(7) = 13	fib6(8) = 21	fib6(9) = 34	fib6(10) = 55	fib6(11) = 89	fib6(12) = 144	fib6(13) = 233	fib6(14) = 377	fib6(15) = 610	fib6(16) = 987	fib6(17) = 1597	fib6(18) = 2584	fib6(19) = 4181	fib6(20) = 6765	fib6(21) = 10946	fib6(22) = 17711	fib6(23) = 28657	fib6(24) = 46368	fib6(25) = 75025	fib6(26) = 121393	fib6(27) = 196418	fib6(28) = 317811	fib6(29) = 514229	fib6(30) = 832040	fib6(31) = 1346269	fib6(32) = 2178309	fib6(33) = 3524578	fib6(34) = 5702887	fib6(35) = 9227465	fib6(36) = 14930352	fib6(37) = 24157817	fib6(38) = 39088169	fib6(39) = 63245986	fib6(40) = 102334155	fib6(41) = 165580141	fib6(42) = 267914296	fib6(43) = 433494437	fib6(44) = 701408733	fib6(45) = 1134903170	fib6(46) = 1836311903	fib6(47) = 2971215073	fib6(48) = 4807526976	fib6(49) = 7778742049	fib6(50) = 12586269025	

fib6(50)을 실행하면 피보나찌 수열의 51개 숫자가 출력되며 `for i in fib6(50):`에서 매 반복마다 fib6()의 `yield`문이 실행된다.  
만약 fib6(50)의 끝에 도달하여 더 이상 반환될 yield가 없다면 for문은 반복을 종료한다.


```python

```
